/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PokerRangePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultRange: ""
};
var PokerRangePlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.grid = new Grid("default", this.settings.defaultRange.split(","), (selectedCodes, id) => {
    });
    this.addSettingTab(new PokerRangeSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor("poker-range", (source, el, ctx) => {
      var _a;
      const lines = source.split("\n");
      let range = this.settings.defaultRange;
      let gridId = this.generateUniqueId();
      if (lines[0].startsWith("<!-- grid-id:")) {
        gridId = ((_a = lines[0].match(/<!-- grid-id:\s*(.+?)\s*-->/)) == null ? void 0 : _a[1]) || gridId;
        range = lines.slice(1).join(",").trim() || range;
      } else {
        range = source.trim() || range;
      }
      const grid = new Grid(gridId, range.split(","), (selectedCodes, id) => {
        this.updateCodeBlock(ctx, selectedCodes.join(","), id);
      });
      el.appendChild(grid.render());
    });
    this.addCommand({
      id: "insert-poker-range",
      name: "Insert Poker Range Table",
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const range = this.settings.defaultRange;
        const gridId = this.generateUniqueId();
        const content = `\`\`\`poker-range
<!-- grid-id: ${gridId} -->
${range}
\`\`\`
`;
        editor.replaceRange(content, cursor);
        const endPos = editor.offsetToPos(editor.posToOffset(cursor) + content.length);
        editor.setCursor(endPos);
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async updateCodeBlock(ctx, newRange, gridId) {
    const file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let inCodeBlock = false;
    let codeBlockStart = -1;
    let codeBlockEnd = -1;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim().startsWith("```poker-range")) {
        inCodeBlock = true;
        codeBlockStart = i;
      } else if (inCodeBlock && lines[i].trim() === "```") {
        codeBlockEnd = i;
        const blockContent = lines.slice(codeBlockStart, codeBlockEnd + 1).join("\n");
        if (blockContent.includes(`<!-- grid-id: ${gridId} -->`)) {
          lines[codeBlockStart + 1] = `<!-- grid-id: ${gridId} -->`;
          lines[codeBlockStart + 2] = newRange;
          const updatedContent = lines.join("\n");
          await this.app.vault.modify(file, updatedContent);
          return;
        }
        inCodeBlock = false;
      }
    }
  }
  generateUniqueId() {
    return `grid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
};
var Grid = class {
  constructor(id, selectedCodes = [], onSelectionChange) {
    this.values = ["A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2"];
    this.isSelecting = false;
    this.lastSelectedState = null;
    this.id = id;
    this.selectedCodes = new Set(selectedCodes);
    this.onSelectionChange = onSelectionChange;
  }
  render() {
    const grid = document.createElement("div");
    grid.className = "poker-range-grid";
    grid.setAttribute("data-grid-id", this.id);
    grid.addEventListener("mousedown", () => this.isSelecting = true);
    grid.addEventListener("mouseup", () => {
      this.isSelecting = false;
      this.lastSelectedState = null;
    });
    grid.addEventListener("mouseleave", () => {
      this.isSelecting = false;
      this.lastSelectedState = null;
    });
    for (let i = 0; i < 13; i++) {
      for (let j = 0; j < 13; j++) {
        const cell = document.createElement("div");
        cell.className = "poker-range-cell";
        cell.style.userSelect = "none";
        let content;
        if (i < j) {
          content = `${this.values[i]}${this.values[j]}s`;
          cell.classList.add("poker-range-suited");
        } else if (i > j) {
          content = `${this.values[j]}${this.values[i]}o`;
          cell.classList.add("poker-range-offsuit");
        } else {
          content = `${this.values[j]}${this.values[i]}`;
          cell.classList.add("poker-range-pair");
        }
        cell.textContent = content;
        if (this.selectedCodes.has(content)) {
          cell.classList.add("poker-range-selected");
        }
        cell.addEventListener("mousedown", (e) => this.handleCellInteraction(cell, content, e));
        cell.addEventListener("mouseover", (e) => this.handleCellInteraction(cell, content, e));
        grid.appendChild(cell);
      }
    }
    return grid;
  }
  handleCellInteraction(cell, content, event) {
    if (event.type === "mousedown" || event.type === "mouseover" && this.isSelecting) {
      if (this.lastSelectedState === null) {
        this.lastSelectedState = !this.selectedCodes.has(content);
      }
      this.toggleCell(cell, content, this.lastSelectedState);
    }
  }
  toggleCell(cell, content, forceState) {
    const newState = forceState !== void 0 ? forceState : !this.selectedCodes.has(content);
    if (newState) {
      this.selectedCodes.add(content);
      cell.classList.add("poker-range-selected");
    } else {
      this.selectedCodes.delete(content);
      cell.classList.remove("poker-range-selected");
    }
    this.onSelectionChange(Array.from(this.selectedCodes), this.id);
  }
  getSelectedCodes() {
    return Array.from(this.selectedCodes);
  }
  setSelectedCodes(codes) {
    this.selectedCodes = new Set(codes);
  }
};
var PokerRangeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Default Range").setDesc("Set the default poker range (comma-separated)").addText((text) => text.setPlaceholder("AKs,QJs").setValue(this.plugin.settings.defaultRange).onChange(async (value) => {
      this.plugin.settings.defaultRange = value;
      await this.plugin.saveSettings();
      this.updateGrid();
    }));
    this.gridContainer = containerEl.createDiv("poker-range-grid-container");
    this.updateGrid();
  }
  updateGrid() {
    this.gridContainer.empty();
    const grid = this.plugin.grid.render();
    this.gridContainer.appendChild(grid);
  }
};
